#summary An explanation of pogel's physics engine.

== Introduction ==

Here I will outline the basic principals of the custom physics engine that pogel uses.
I do not pretend that to know the actual math that goes into these things, nor the proper terms for them.

== Wait... What? Its not automatic? ==

The one thing that drives pogel's physics engine is collision detection, which involves math that is way over my head, possibly yours as well, and no it doesn't just happen. In real life collisions happen when two things try to move into the same space they "touch" and stop, due to their densities and states of matter. On a computer, things can _occupy the same space_ wherever and whenever, so we must calculate when two things are touching (going through each other really).

== Getting a "Frame" of reference ==

Have you ever herd of the term "FPS", no not the First Person Shooter game genre, _Frames Per Second_, this is pretty much a speed, like miles per hour ("mph"), but it is more visual. FPS is literally how many times your screen is changed in one second, or there abouts. The human eye has a FPS of about 15 to 20, usually 18, an average theatrical movie is most likely going to be 24, maybe higher if it is in the new-fangled 3D, because they have to do one frame per eye per normal frame (2 eyes, 24fps normally, 2*24 = 48), so it would be about 50 to 60FPS. The point I am trying to make is that for every frame, there are millions of calculations within pogel, each frame is a step in time, an iteration. 

== "Move out of the way!" ==

Now down to how things stop, as I said earlier, in reality things hit and touch to not occupy the same space, well in pogel first things move to be in the same space, then  we move them so that they are not occupying the same space. This is sort of like two cars crashing, the engine blocks 'fusing' together, and no damage to anything, they are just occupying the same space, then they start to slowly move apart, until they aren't touching anymore. I know it is not a very good explanation.

Like this:

http://pogel.googlecode.com/svn/wiki/pogel_intercection.png

Impossibly intersecting.

This is how we move them:
 # check if the two objects are intersecting and if we have not exceeded the maximum iterations.
 # translate the first object in the opposite direction that it came, in very small increments.
 # repeat step #2 for the second object.
 # increment the iteration count.
 # repeat steps #1 to #5 until step #1 is false.

Here it is in pseudo-code:
{{{

float precision = 0.01;
int itter = 0;

while( intersecting(object_1, object_2) && itter < 1000 ) {
    object_1.translate(object_1.direction * -1.0 * precision);
    object_2.translate(object_2.direction * -1.0 * precision);
    itter++;
}
}}}

this does not take into account rotation nor other complex physical dynamics and properties of the objects, but it is a simple example that works very well for small applications.